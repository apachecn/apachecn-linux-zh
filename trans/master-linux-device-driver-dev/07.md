# *第 7 章*：揭开 V4L2 和视频捕获设备驱动程序的神秘面纱

长期以来，视频一直是嵌入式系统固有的特性。 鉴于 Linux 是此类系统中最受欢迎的内核，不用说，它本身就嵌入了对视频的支持。 这就是所谓的**V4L2**，它代表**Video 4(For)Linux2**。 是的！*2*因为有第一个版本，*V4L*。 V4L2 在 V4L 中增加了内存管理特性和其他元素，使该框架尽可能具有通用性。 通过这个框架，Linux 内核能够处理摄像机设备和它们所连接的网桥，以及相关的 DMA 引擎。 这些不是 V4L2 支持的唯一元素。 我们将从介绍框架体系结构开始，学习它是如何组织的，并介绍它包含的主要数据结构。 然后，我们将学习如何设计和编写负责 DMA 操作的桥接设备驱动程序，最后，我们将深入研究子设备驱动程序。 也就是说，本章将介绍以下主题：

*   框架体系结构和主要数据结构
*   桥接视频设备驱动程序
*   子设备的概念
*   V4L2 控制基础架构

# 技术要求

以下是本章的前提条件：

*   具备高级计算机体系结构知识和 C 编程技能
*   Linux 内核 v4.19.X 源代码，可从[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)获得

# 框架架构和主要数据结构

视频设备正变得越来越复杂。 在这类设备中，硬件通常由几个集成 IP 组成，这些 IP 需要以受控方式相互配合，这就导致了复杂的 V4L2 驱动程序。 这需要在钻研代码之前弄清楚体系结构，这正是本节要解决的要求。

众所周知，驱动程序通常在编程时反映硬件模型。 在 V4L2 上下文中，各种 IP 组件被建模为称为子设备的软件块。 V4L2 子设备通常是纯内核对象。 此外，如果 V4L2 驱动程序实现媒体设备 API(我们将在下一章[*第 8 章*](08.html#_idTextAnchor342)，*与 V4L2 异步和媒体控制器框架*集成)实现媒体设备 API，这些子设备将自动从媒体实体继承，从而允许应用程序枚举子设备并使用媒体框架的实体、垫和与链接相关的枚举 API 发现硬件拓扑。

尽管使子设备可被发现，但驱动程序同样可以决定以一种简单的方式使它们可由应用程序配置。 当子设备驱动程序和 V4L2 设备驱动程序都支持这一点时，子设备将在上有一个字符设备节点，可以调用**ioctls**(**输入/输出控件**)来查询、读取和写入子设备功能(包括控件)，甚至协商各个子设备焊盘上的图像格式。

在驱动程序级别，V4L2 为驱动程序开发人员做了大量工作，因此他们只需实现与硬件相关的代码并注册相关设备。 在进一步讨论之前，我们必须介绍构成 V4L2 核心的几个重要结构：

*   `struct v4l2_device`：硬件设备可以包含多个子设备，例如除了捕获设备之外的电视卡，并且可能包含 VBI 设备或 FM 调谐器。 `v4l2_device`是所有这些设备的根节点，负责管理所有子设备。
*   `struct video_device`：此结构的主要目的是提供众所周知的`/dev/videoX`或`/dev/v4l-subdevX`设备节点。 此结构主要抽象捕获接口，也称为**桥接接口**(桥接，因为它将数据从其数据线传送到内核内存)。 这将始终是 SoC 的一部分或连接到高速总线(如 PCI)。 虽然子设备也继承自此结构，但它们的使用方式与桥不同，但仅限于公开它们的`/dev/v4l-subdevX`节点及其文件操作。 从子设备驱动程序内部，只有内核访问底层子设备中的该结构。
*   `struct vb2_queue`：对我来说，这是视频驱动程序中的主要数据结构，因为它与`struct vb2_v4l2_buffer`一起用于数据流的真实逻辑和 DMA 操作的中心部分。
*   `struct v4l2_subdev`：这是 SoC 的视频系统中负责实现特定功能和抽象特定功能的子设备。

可以将`struct video_device`视为所有设备和子设备的基类。 当我们编写自己的驱动程序时，对此数据结构的访问可能是直接的(如果我们处理的是桥驱动程序)，也可能是间接的(如果我们处理的是子设备，因为子设备 API 抽象并隐藏了嵌入到每个子设备数据结构中的底层`struct video_device`)。

现在我们知道这个框架是由哪些数据结构组成的。 此外，我们还介绍了它们之间的关系和各自的目的。 现在是时候让我们通过介绍如何使用 SY词干初始化和注册 V4L2 设备来更深入地了解细节了。

## 初始化和注册 V4L2 设备

在使用或系统的一部分之前，必须对 V4L2 设备进行初始化和注册，这是本节的主要主题。 一旦框架体系结构描述完成，我们就可以开始浏览代码了。 在该内核中，V4L2 设备是`struct v4l2_device`结构的实例。 这是媒体框架中的最高数据结构，维护媒体管道组成的子设备列表，并充当网桥设备的父设备。 V4L2 驱动程序应包括`<media/v4l2-device.h>`，这将引入以下定义`struct v4l2_device`：

```
struct v4l2_device {
    struct device *dev;
    struct media_device *mdev;
    struct list_head subdevs;
    spinlock_t lock;
    char name[V4L2_DEVICE_NAME_SIZE];
    void (*notify)(struct v4l2_subdev *sd,
                   unsigned int notification, void *arg);
    struct v4l2_ctrl_handler *ctrl_handler;
    struct v4l2_prio_state prio;
    struct kref ref;
    void (*release)(struct v4l2_device *v4l2_dev);
};
```

与我们将在以下部分介绍的其他视频相关数据结构不同，此结构中只有个字段。 它们的含义如下：

*   `dev`是指向此 V4L2 设备的父`struct device`的指针。 这将在注册时自动设置，`dev->driver_data`将指向此`v4l2`结构。
*   `mdev`是指向此 V4L2 设备所属的`struct media_device`对象的指针。 此字段涉及媒体控制器框架，将在相关部分中介绍。 如果不需要与媒体控制器框架集成，则可以是`NULL`。
*   `subdevs`是此 V4L2 设备的子设备列表。
*   `lock`是保护进入此结构的锁。
*   `name`是此 V4L2 设备的唯一名称。 默认情况下，它派生自驱动程序名称加上总线 ID。
*   `notify`是指向通知回调的指针，由子设备调用以将某些事件通知此 V4L2 设备。
*   `ctrl_handler`是与此设备关联的控制处理程序。 它跟踪此 V4L2 设备拥有的所有控件。 如果没有控件，则可能是`NULL`。
*   `prio`是设备的优先级状态。
*   `ref`由内核内部用于引用计数。
*   `release`是此结构的最后一个用户关闭时要调用的回调。

此顶层结构由相同的函数`v4l2_device_register()`初始化并注册到核心，其原型如下：

```
int v4l2_device_register(struct device *dev,
                         struct v4l2_device *v4l2_dev);
```

第一个`dev`参数通常是桥接总线的相关设备数据结构的 struct 设备指针。 即`pci_dev`、`usb_device`或`platform_device`。

如果`dev->driver_data`字段为`NULL`，此函数将使其指向正在注册的实际`v4l2_dev`对象。 此外，如果`v4l2_dev->name`为空，则它将被设置为由`dev driver name + dev device name`串联而成的值。

但是，如果`dev`参数为`NULL`，则在调用`v4l2_device_register()`之前必须设置`v4l2_dev->name`。 另一方面，以前注册的 V4L2 设备可以使用`v4l2_device_unregister()`取消注册，如下所示：

```
v4l2_device_unregister(struct v4l2_device *v4l2_dev);
```

在调用此函数时，所有子设备也将被注销。 这一切都是关于 V4L2 设备的。 但是，您应该记住，它是顶层结构，维护媒体设备的子设备列表，并充当网桥设备的父设备。

现在我们已经完成了主 V4L2 设备(包含其他设备相关数据结构)的初始化和注册，我们可以介绍特定的设备驱动程序，从桥接驱动程序开始，它是 PlatfoRM 特定的。

# 视频设备驱动程序简介-网桥驱动程序

网桥驱动程序控制负责 DMA 传输的平台`/USB/PCI/...`硬件。 此是处理来自设备的数据流的驱动程序。 桥驱动程序直接处理的主要数据结构之一是`struct video_device`。 这个结构嵌入了执行视频流所需的整个元素，它与用户空间的第一次交互之一是在`/dev/`目录中创建设备文件。

`struct video_device`结构在`include/media/v4l2-dev.h`中定义，这意味着驱动程序代码必须包含`#include <media/v4l2-dev.h>`。 下面是定义该结构的头文件中的结构：

```
struct video_device
{
#if defined(CONFIG_MEDIA_CONTROLLER)
    struct media_entity entity;
    struct media_intf_devnode *intf_devnode;
    struct media_pipeline pipe;
#endif
    const struct v4l2_file_operations *fops;
    u32 device_caps;
    struct device dev; struct cdev *cdev;
    struct v4l2_device *v4l2_dev;
    struct device *dev_parent;
    struct v4l2_ctrl_handler *ctrl_handler;
    struct vb2_queue *queue;
    struct v4l2_prio_state *prio;
    char name[32];
    enum vfl_devnode_type vfl_type;
    enum vfl_devnode_direction vfl_dir;
    int minor;
    u16 num;
    unsigned long flags; int index;
    spinlock_t fh_lock;
    struct list_head fh_list;
    void (*release)(struct video_device *vdev);
    const struct v4l2_ioctl_ops *ioctl_ops;
    DECLARE_BITMAP(valid_ioctls, BASE_VIDIOC_PRIVATE);
    struct mutex *lock;
};
```

网桥驱动程序不仅使用此结构-当涉及到表示 V4L2 兼容设备(包括子设备)时，此结构是主要的`v4l2`结构。 但是，根据驱动程序的性质(桥接驱动程序或子设备驱动程序)，某些元素可能会有所不同或可能是`NULL`。 下面是对结构中每个元素的说明：

*   `entity`、`intf_node`和`pipe`是与媒体框架集成的一部分，我们将在同名部分看到。 前者从媒体框架中抽象出视频设备(成为实体)，`intf_node`表示媒体接口设备节点，`pipe`表示实体所属的流媒体管道。
*   `fops`表示视频设备的文件节点的文件操作。 V4L2 核心使用子系统所需的一些额外逻辑覆盖虚拟设备文件操作。
*   `cdev`是字符设备结构，抽象了底层的`/dev/videoX`文件节点。 `vdev->cdev->ops`由 V4L2 内核设置为`v4l2_fops`(在`drivers/media/v4l2-core/v4l2-dev.c`中定义)。 `v4l2_fops`实际上是分配给每个`/dev/videoX`字符设备的通用(就实现的操作而言)和面向 V4L2 的(就这些操作所做的而言)文件 op，并包装`vdev->fops`中定义的特定于视频设备的 op。 在它们的返回路径上，`v4l2_fops`中的每个回调都将调用`vdev->fops`中的对应回调。 `v4l2_fops`回调在调用`vdev->fops`中的实际操作之前执行健全性检查。 例如，对于用户空间对`/dev/videoX`文件发出的`mmap()`系统调用，将首先调用`v4l2_fops->mmap`，这将确保在调用之前设置了`vdev->fops->mmap`，并在需要时打印调试消息。
*   `ctrl_handler`：默认值为`vdev->v4l2_dev->ctrl_handler`。
*   `queue`是与此设备节点关联的缓冲区管理队列。 这是只有桥接器驱动程序才能使用的数据结构之一。 这可能是`NULL`，特别是当涉及到非网桥视频驱动程序(例如子设备)时。
*   `prio`是指向具有设备优先级状态的`&struct v4l2_prio_state`的指针。 如果此状态为`NULL`，则将使用`v4l2_dev->prio`。
*   `name`是视频设备的名称。
*   `vfl_type` is the V4L device type. Possible values are defined by `enum vfl_devnode_type`, containing the following:

    -`VFL_TYPE_GRABBER`：用于视频输入/输出设备

    -`VFL_TYPE_VBI`：垂直空白数据(未解码)

    -`VFL_TYPE_RADIO`：用于无线网卡

    -`VFL_TYPE_SUBDEV`：适用于 V4L2 子设备

    -`VFL_TYPE_SDR`：软件定义无线电

    -`VFL_TYPE_TOUCH`：用于触摸传感器

*   `vfl_dir` is a V4L receiver, transmitter, or memory-to-memory (denoted m2m or mem2mem) device. Possible values are defined by `enum vfl_devnode_direction`, containing the following:

    -`VFL_DIR_RX`：用于捕获设备

    -`VFL_DIR_TX`：用于输出设备

    -`VFL_DIR_M2M`：应为 mem2mem设备(读取内存到内存，也称为内存到内存设备)。 Mem2mem 设备是将用户空间应用程序传递的内存缓冲区用于源和目标的设备。 这与当前和现有的驱动程序不同，这些驱动程序一次只对其中一个使用内存缓冲区。 根据 V4L2，这样的设备可以是**输出**和**捕获**两种类型。 虽然在 V4L2 框架中不存在这样的设备，但是存在对这样的模型的需求，例如，对‘大小调整设备’或对 V4L2 环回驱动程序的需求。

*   `v4l2_dev`是此视频设备的`v4l2_device`父设备。
*   `dev_parent`是此视频设备的设备父设备。 如果未设置，内核将用`vdev->v4l2_dev->dev`设置。
*   `ioctl_ops`是指向`&struct v4l2_ioctl_ops`的指针，它定义了一组 ioctl 回调。
*   `release`是视频设备的最后一个用户退出时由内核调用的回调。 这必须是非`NULL`。
*   `lock`是串行化对此设备的访问的互斥体。 它是通过对所有 ioctls 进行序列化的主要序列化锁。 网桥驱动程序通常使用与*队列->锁*相同的互斥量来设置此字段，后者是用于序列化对队列的访问(串行化数据流)的锁。 但是，如果设置了*队列->锁*，则流 ioctls 将由该单独的锁序列化。
*   `num`是内核分配的实际设备节点索引。 它对应于`/dev/videoX`中的*X*。
*   `flags`是视频设备标志。 您应该使用位操作来设置/清除/测试标志。 它们包含一组`&enum v4l2_video_device_flags`标志。
*   `fh_list`是描述 V4L2 文件处理程序的`struct v4l2_fh`列表，可跟踪该视频设备打开的文件句柄数量。 `fh_lock`是与此列表关联的锁。
*   `class`对应于 sysfs 类。 它是由核心分配的。 此类条目对应于`/sys/video4linux/`sysfs 目录。

## 初始化和注册视频设备

在其注册之前，可以使用`video_device_alloc()`(其简单地调用`kzalloc()`)动态地分配视频设备，或者静态地将嵌入到动态分配的结构中，该结构通常是设备状态结构。

视频设备使用`video_device_alloc()`动态分配，如下例所示：

```
struct video_device * vdev;
vdev = video_device_alloc();
if (!vdev)
    return ERR_PTR(-ENOMEM);
vdev->release = video_device_release;
```

在前面的摘录中，最后一行为视频设备提供了`release`方法，因为`.release`字段必须为非`NULL`。 `video_device_release()`回调由内核提供。 它只调用`kfree()`来释放分配的内存。

当它嵌入到设备状态结构中时，代码如下：

```
struct my_struct {
    [...]
    struct video_device vdev;
};
[...]
struct my_struct *my_dev;
struct video_device *vdev;
my_dev =	kzalloc(sizeof(struct my_struct), GFP_KERNEL);
if (!my_dev)
    return ERR_PTR(-ENOMEM);
vdev = &my_vdev->vdev;
/* Now work with vdev as our video_device struct */
vdev->release = video_device_release_empty;
[...]
```

这里，视频设备不能单独发布，因为它是更大画面的一部分。 当视频设备嵌入到另一个结构中时，如前面的示例所示，它不需要释放任何内容。 此时，因为 Release 回调必须是非`NULL`的，所以我们可以分配一个空函数，比如内核提供的`video_device_release_empty()`。

我们已经完成了分配。 此时，我们可以使用`video_register_device()`来注册视频设备。 以下是该函数的原型：

```
int video_register_device(struct video_device *vdev,
                           enum vfl_devnode_type type, int nr)
```

在前面的原型中，`type`指定要注册的网桥设备的类型。 它将被分配到`vdev->vfl_type`字段。 在本章的其余部分，我们将考虑将其设置为`VFL_TYPE_GRABBER`，因为我们处理的是视频捕获接口。 `nr`是所需的设备节点编号(*0==/dev/Video0*，*1==/dev/Video1*，...)。 但是，将其值设置为`-1`将指示内核选择第一个空闲索引并使用它。 指定固定索引对于构建精巧的*udev*规则可能很有用，因为设备节点名称是预先知道的。 要成功注册，必须满足以下要求：

*   首先，您*必须*设置`vdev->release`函数，因为它不能为空。 如果您不需要它，可以传递 V4L2 内核的 Empty Release 方法。
*   其次，您*必须*设置`vdev->v4l2_dev`指针；它应该指向视频设备的 V4L2 父设备。
*   最后，但不是强制的，您应该设置`vdev->fops`和`vdev->ioctl_ops`。

`video_register_device()`成功时返回`0`。 但是，如果没有空闲的次要设备，如果可以找到设备节点号，或者如果设备节点注册失败，则可能会失败。 在任何一种错误情况下，它都会返回一个负错误号。 每个注册的视频设备在`/sys/class/video4linux`中创建一个目录条目，其中包含一些属性。

重要音符

除非使用内核选项`CONFIG_VIDEO_FIXED_MINOR_RANGES`编译内核，否则会动态分配次要编号。 在这种情况下，根据设备节点类型(视频、无线电等)在范围内分配次要号码，总限制为`VIDEO_NUM_DEVICES`，设置为`256`。

如果注册失败，则不会调用`vdev->release()`回调。 在这种情况下，如果已动态分配已分配的`video_device`结构，则需要调用来释放已分配的`video_device`结构，或者如果`video_device`嵌入其中，则需要释放您自己的结构。

在驱动程序的卸载路径上，或者不再需要视频节点时，需要在视频设备上调用`video_unregister_device()`进行注销，这样才能移除视频设备的节点：

```
void video_unregister_device(struct video_device *vdev)
```

在前面的调用之后，设备 sysfs 条目将被删除，从而导致*udev*删除`/dev/`中的节点。

到目前为止，我们只讨论了注册过程中最简单的部分，但视频设备中有一些复杂的字段需要在注册之前进行初始化。 这些字段通过提供视频设备文件操作、一组连贯的 ioctl 回调以及最重要的媒体队列和内存管理接口来扩展驱动程序功能。 我们将在接下来的章节中讨论这些问题。

## 视频设备文件操作

视频设备(通过其驱动程序)是作为`/dev/`目录中的特殊文件向用户空间公开的，用户空间可以使用该文件与底层设备进行交互：流式传输数据。 为了使视频设备能够处理用户空间查询(通过系统调用)，必须从驱动程序内部实现一组标准回调。 这些回调形成今天称为**文件操作**的。 视频设备的文件操作结构为`struct v4l2_file_operations`类型，在`include/media/v4l2-dev.h`中定义如下：

```
struct v4l2_file_operations {
    struct module *owner;
    ssize_t (*read) (struct file *file, char user *buf,
                       size_t, loff_t *ppos);
    ssize_t (*write) (struct file *file, const char user *buf,
                       size_t, loff_t *ppos);
    poll_t (*poll) (struct file *file,
                      struct poll_table_struct *);
    long (*unlocked_ioctl) (struct file *file,
                          unsigned int cmd, unsigned long arg);
#ifdef CONFIG_COMPAT
     long (*compat_ioctl32) (struct file *file,
                          unsigned int cmd, unsigned long arg);
#endif
    unsigned long (*get_unmapped_area) (struct file *file,
                              unsigned long, unsigned long,
                              unsigned long, unsigned long);
    int (*mmap) (struct file *file,                  struct vm_area_struct *vma);
    int (*open) (struct file *file);
    int (*release) (struct file *file);
};
```

这些可以被视为顶级回调，因为它们实际上被另一个低级设备文件 OP 调用(当然，在多次健全性检查之后)，该低级设备文件 OP 这次与`vdev->cdev`字段相关联，并且在创建文件节点时用`vdev->cdev->ops = &v4l2_fops;`设置了。 这允许内核实现额外的逻辑并强制执行健全性：

*   `owner`是指向模块的指针。 大多数情况下，它是`THIS_MODULE`。
*   `open`应包含实现`open()`系统调用所需的操作。 大多数情况下，可以将其设置为`v4l2_fh_open`，这是一个 V4L2 帮助器，它简单地分配和初始化一个`v4l2_fh`结构，并将其添加到`vdev->fh_list`列表中。 但是，如果您的设备需要一些额外的初始化，请在内部执行初始化，然后调用`v4l2_fh_open(struct file * filp)`。 无论如何，你*必须*处理`v4l2_fh_open`。
*   `release` should contain operations needed to implement the `close()` system call. This callback must deal with `v4l2_fh_release`. It can be set to either of the following:

    -`vb2_fop_release`，它是一个 Videobuf2-V4L2 发布帮助器，可以清理任何正在进行的流媒体。 这个帮助器将调用`v4l2_fh_release`。

    -您的自定义回调，撤消在`.open`中已完成的操作，并且必须直接或间接调用`v4l2_fh_release`(例如，使用`_vb2_fop_release()`帮助器，以便 V4L2 内核处理任何正在进行的流的清理)。

*   `read`应包含实现`read()`系统调用所需的操作。 大多数情况下，Videobuf2-V4L2 辅助对象`vb2_fop_read`就足够了。
*   在我们的情况下不需要`write`，因为它适用于输出型设备。 但是，在这里使用`vb2_fop_write`可以完成这项工作。
*   如果使用`v4l2_ioctl_ops`，则必须将`unlocked_ioctl`设置为`video_ioctl2`。 下一节将详细说明这一点。 此 V4L2 核心帮助器是`__video_do_ioctl()`的包装器，它处理实际逻辑，并将每个 ioctl 路由到`vdev->ioctl_ops`中的适当回调，在`vdev->ioctl_ops`中定义了各个 ioctl 处理程序。
*   `mmap`应包含实现`mmap()`系统调用所需的操作。 大多数情况下，Videobuf2-V4L2 帮助器`vb2_fop_mmap`就足够了，除非在执行映射之前需要额外的元素。 内核中的视频缓冲区(响应`VIDIOC_REQBUFS`ioctl 而分配)在访问用户空间之前必须单独映射。 这就是这个`.mmap`回调的目的，它只需将一个且只有一个视频缓冲区映射到用户空间。 使用`VIDIOC_QUERYBUF`ioctl 向内核查询将缓冲区映射到用户空间所需的信息。 给定`vma`参数，您可以获取指向相应视频缓冲区的指针，如下所示：

    ```
    struct vb2_queue *q = container_of_myqueue_wrapper();
    unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
    struct vb2_buffer *vb;
    unsigned int buffer = 0, plane = 0;
    for (i = 0; i < q->num_buffers; i++) {
        struct vb2_buffer *buf = q->bufs[i];
        /* The below assume we are on a single-planar system,
         * else we would have loop over each plane
         */
        if (buf->planes[0].m.offset == off)
            break;
        return i;
    }
    videobuf_queue_unlock(myqueue);
    ```

*   `poll`应包含实现`poll()`系统调用所需的操作。 大多数情况下，Videobuf2-V4L2 辅助对象`vb2_fop_call`就足够了。 如果这个帮助器不知道如何锁定(`queue->lock`和`vdev->lock`都没有设置)，那么您不应该使用它，但是您应该编写自己的帮助器，它可以依赖于不处理锁定的`vb2_poll()`帮助器。

在这两个回调中，您都可以使用`v4l2_fh_is_singular_file()`帮助器来检查给定的文件是否是为关联的`video_device`打开的唯一文件句柄。 它的替代方案是`v4l2_fh_is_singular()`，这次依赖于`v4l2_fh`：

```
int v4l2_fh_is_singular_file(struct file *filp)
int v4l2_fh_is_singular(struct v4l2_fh *fh);
```

综上所述，以下是捕获视频设备驱动程序的文件操作可能是什么样子：

```
static int foo_vdev_open(struct file *file)
{
    struct mydev_state_struct *foo_dev = video_drvdata(file);
    int ret;
[...]
    if (!v4l2_fh_is_singular_file(file))
        goto fh_rel;
[...]
fh_rel:
    if (ret)
        v4l2_fh_release(file);
    return ret;
}
static int foo_vdev_release(struct file *file)
{
    struct mydev_state_struct *foo_dev = video_drvdata(file);
    bool fh_singular;
    int ret;
[...]
    fh_singular = v4l2_fh_is_singular_file(file);
    ret = _vb2_fop_release(file, NULL);
    if (fh_singular)
        /* do something */
        [...]
    return ret;
}
static const struct v4l2_file_operations foo_fops = {
    .owner = THIS_MODULE,
    .open = foo_vdev_open,
    .release = foo_vdev_release,
    .unlocked_ioctl = video_ioctl2,
    .poll = vb2_fop_poll,
    .mmap = vb2_fop_mmap,
    .read = vb2_fop_read,
};
```

您可以观察到，在前面的块中，我们在ﬁLE 操作中只使用了标准的核心助手。

重要音符

Mem2mem 设备可以使用其相关的基于 V4L2-mem2mem 的助手。 看看`drivers/media/v4l2-core/v4l2-mem2mem.c`。

## V4L2 ioctl 处理

让我们更多地讨论一下关于`v4l2_file_operations.unlocked_ioctl`回调。 正如我们在上一节中看到的，它应该设置为`video_ioctl2`。 `video_ioctl2`负责内核和用户空间之间的参数复制，并在将每个单独的`ioctl()`调用分派给驱动程序之前执行一些健全性检查(例如，ioctl 命令是否有效)，这以`video_device->ioctl_ops`字段中的回调条目结束，该字段的类型为`struct v4l2_ioctl_ops`。

`struct v4l2_ioctl_ops`结构包含 V4L2 框架中每个可能的 ioctl 的回调。 但是，您应该仅根据设备的类型和驱动程序的功能来设置这些设置。 结构中的每个回调都映射一个 ioctl，Strc定义如下：

```
struct v4l2_ioctl_ops {
    /* VIDIOC_QUERYCAP handler */
    int (*vidioc_querycap)(struct file *file, void *fh,
                            struct v4l2_capability *cap);
    /* Buffer handlers */
    int (*vidioc_reqbufs)(struct file *file, void *fh,
                           struct v4l2_requestbuffers *b);
    int (*vidioc_querybuf)(struct file *file, void *fh,
                            struct v4l2_buffer *b);
    int (*vidioc_qbuf)(struct file *file, void *fh,
                        struct v4l2_buffer *b);
    int (*vidioc_expbuf)(struct file *file, void *fh,
                          struct v4l2_exportbuffer *e);
    int (*vidioc_dqbuf)(struct file *file, void *fh,
                          struct v4l2_buffer *b);
    int (*vidioc_create_bufs)(struct file *file, void *fh,
                               struct v4l2_create_buffers *b);
    int (*vidioc_prepare_buf)(struct file *file, void *fh,
                               struct v4l2_buffer *b);
    int (*vidioc_overlay)(struct file *file, void *fh,
                           unsigned int i);
[...]
};
```

该结构有 120 多个条目，描述了每个可能的 V4L2ioctl 的操作，无论设备类型是什么。 在前面的摘录中，只列出了我们可能感兴趣的内容。 我们不会在此结构中引入回调。 但是，当您达到[*第 9 章*](09.html#_idTextAnchor396)，*从用户空间*利用 V4L2API 时，我鼓励您回到这个结构，事情就会变得更加清晰。

也就是说，因为您提供了回调，所以它仍然可以访问。 在某些情况下，您可能希望忽略在`v4l2_ioctl_ops`中指定的回调。 如果基于外部因素(例如，正在使用哪张卡)想要关闭`v4l2_ioctl_ops`中的某些特性，而不必创建新的结构，则往往需要这样做。 为了让内核知道这一点并忽略回调，您应该在调用`video_register_device()`之前对有问题的 ioctl 命令调用`v4l2_disable_ioctl()`：

```
v4l2_disable_ioctl (vdev, cmd)
```

下面是一个示例：`v4l2_disable_ioctl(&tea->vd, VIDIOC_S_HW_FREQ_SEEK);`。 上一次调用会将`VIDIOC_S_HW_FREQ_SEEK`ioctl 标记为在`tea->vd`视频设备上忽略。

## Videobuf2 接口和接口

使用 Videobuf2 框架连接 V4L2 驱动器层和用户空间层，提供一个可以分配和管理视频帧数据的数据交换通道。 Videobuf2 内存管理后端是完全模块化的。 这允许插入具有非标准内存管理要求的设备和平台的自定义内存管理例程，而无需更改高级缓冲区管理功能和 API。 该框架提供以下内容：

*   实现流式 I/O V4L2ioctls 和文件操作
*   高级视频缓冲器、视频队列和状态管理功能
*   视频缓冲存储器分配和管理

Videobuf2(或简称为 vb2)促进了驱动程序开发，减少了驱动程序的代码大小，并有助于在驱动程序中正确和一致地实现 V4L2API。 然后，V4L2 驱动器负责从传感器(通常通过某种 DMA 控制器)获取视频数据，并馈送到由 VB2 框架管理的缓冲器。

该框架实现了许多 ioctl 功能，包括缓冲区分配、入队、出队和数据流控制。 然后，它不再推荐任何特定于供应商的解决方案，从而显著减少了媒体框架代码大小，并简化了编写 V4L2 设备驱动程序所需的工作。

重要音符

每个 Videobuf2 帮助器、API 和数据结构都以`vb2_`为前缀，而版本 1(Videobuf，在`drivers/media/v4l2-core/videobuf-core.c`中定义)使用前缀`videobuf_`。

此框架包括许多概念，其中一些人可能对很熟悉，但仍需要详细讨论这些概念。

### 缓冲区的概念

缓冲器是在 VB2 和用户空间之间以次单次交换的数据单位。 从用户空间代码的观点来看，V4L2 缓冲器表示对应于视频帧的数据(例如，在捕获设备的情况下)。 流需要在内核和用户空间之间交换缓冲区。 VB2 使用`struct vb2_buffer`数据结构来描述视频缓冲区。 该结构在`include/media/videobuf2-core.h`中定义如下：

```
struct vb2_buffer {
    struct vb2_queue *vb2_queue;
    unsigned int index;
    unsigned int type;
    unsigned int memory;
    unsigned int num_planes;
    u64 timestamp;
    /* private: internal use only
     *
     * state: current buffer state; do not change
     * queued_entry: entry on the queued buffers list, which
     * holds all buffers queued from userspace
     * done_entry: entry on the list that stores all buffers
     * ready to be dequeued to userspace
     * vb2_plane: per-plane information; do not change
     */
    enum vb2_buffer_state state;
    struct vb2_plane planes[VB2_MAX_PLANES];
    struct list_head queued_entry;
    struct list_head done_entry;
[...]
};
```

在前面的 data结构中，那些我们不感兴趣的字段已被删除。 其余字段定义如下：

*   `vb2_queue`是此缓冲区所属的`vb2`队列。 这将把我们带到下一个部分，在那里我们将根据 Videobuf2 介绍队列的概念。
*   `index`是此缓冲区的 ID。
*   `type`是缓冲区的类型。 它由`vb2`在分配时设置。 它与它所属的队列类型相匹配：`vb->type = q->type`。
*   `memory` is the type of memory model used to make the buffers visible on user spaces. The value of this field is of the `enum vb2_memory` type, which matches its V4L2 user space counterpart, `enum v4l2_memory`. This field is set by `vb2` at the time of buffer allocation and reports the vb2 equivalent of the user space value assigned to the `.memory` field of `v4l2_requestbuffers` given to `vIDIOC_REQBUFS`. Possible values include the following:

    -`VB2_MEMORY_MMAP`：用户空间分配的等价物是`V4L2_MEMORY_MMAP`，表示缓冲区用于内存映射 I/O。

    -`VB2_MEMORY_USERPTR`：在用户空间分配的等价物是`V4L2_MEMORY_USERPTR`，表示用户在用户空间分配缓冲区，并通过`v4l2_buffer`的`buf.m.userptr`成员传递指针。 V4L2 中`USERPTR`的目的是允许用户直接或静态地传递用户空间中由`malloc()`分配的缓冲区。

    -`VB2_MEMORY_DMABUF`。 在用户空间中分配的等价物是`V4L2_MEMORY_DMABUF`，表示内存是由驱动程序分配的，并作为 DMABUF 文件处理程序导出。 此 DMABUF 文件处理程序可以导入到另一个驱动程序中。

*   `state` is of the `enum vb2_buffer_state` type and represents the current state of this video buffer. Drivers can use the `void vb2_buffer_done(struct vb2_buffer *vb, enum vb2_buffer_state state)` API in order to change this state. Possible state values include the following:

    -`VB2_BUF_STATE_DEQUEUED`表示缓冲区受用户空间控制。 它由`VIDIOC_REQBUFS`ioctl 执行路径中的 Videobuf2 内核设置。

    -`VB2_BUF_STATE_PREPARING`表示在 Videobuf2 中准备缓冲区。 该标志由 Videobuf2 内核在支持它的驱动程序的`VIDIOC_PREPARE_BUF`ioctl 的执行路径中设置。

    -`VB2_BUF_STATE_QUEUED`表示缓冲区已在 Videobuf 中排队，但尚未在驱动程序中排队。 这是由`VIDIOC_QBUF`ioctl 执行路径中的 Videobuf2 内核设置的。 但是，如果驱动程序无法启动流，则必须将所有缓冲区的状态设置为`VB2_BUF_STATE_QUEUED`。 这相当于将缓冲区返回给 Videobuf2。

    -`VB2_BUF_STATE_ACTIVE`表示缓冲区实际上在驱动程序中排队，可能用于硬件操作(例如 DMA)。 驱动程序不需要设置此标志，因为它是由内核在调用 Buffer`.buf_queue`回调之前设置的。

    -`VB2_BUF_STATE_DONE`表示驱动程序应在此缓冲区上 DMA 操作的成功路径上设置此标志，以便将缓冲区传递给 Vb2。 这对 VideoBuf2 内核意味着缓冲区从驱动程序返回到 VideoBuf，但尚未出列到用户空间。

    -`VB2_BUF_STATE_ERROR`与上面的相同，但缓冲区上的操作以错误结束，出队时将报告给用户空间。

如果在此之后，缓冲技能的概念对您来说很复杂，那么我建议您在回到这里之前，先阅读用户空间中的第 9 章，*，利用 V4L2API 来阅读[*章*](09.html#_idTextAnchor396)，*。**

#### 飞机的概念

有些设备需要将每个输入或输出视频帧的数据放入不连续的内存缓冲区。 在这种情况下，必须使用一个以上的存储器地址来寻址一个视频帧，换言之，每个“平面”一个指针。 平面是当前帧(或帧的一块)的子缓冲区。

因此，在单平面系统中，平面表示整个视频帧，而在多平面系统中，平面仅表示视频帧 I的一块。 由于内存是不连续的，多平面设备使用分散/聚集 DMA。

### 队列的概念

队列是流的中心元素，也是网桥驱动程序的 DMA 引擎相关部分。 事实上，它是司机介绍自己认识 Videobuf2 的要素。 它帮助我们实现了驱动程序中的数据流管理模块。 队列通过以下结构表示：

```
struct vb2_queue {
    unsigned int type;
    unsigned int io_modes;
    struct device *dev;
    struct mutex *lock;
    const struct vb2_ops *ops;
    const struct vb2_mem_ops *mem_ops;
    const struct vb2_buf_ops *buf_ops;
    u32 min_buffers_needed;
    gfp_t gfp_flags;
    void *drv_priv;
    struct vb2_buffer *bufs[VB2_MAX_FRAME];
    unsigned int num_buffers;
    /* Lots of private and debug stuff omitted */
    [...]
};
```

应将结构置零，并填写前面的字段。 以下是结构中每个元素的含义：

*   `type`是缓冲区类型。 应使用`enum v4l2_buf_type`中存在的值之一(在`include/uapi/linux/videodev2.h`中定义)进行设置。 在我们的情况下，这一定是`V4L2_BUF_TYPE_VIDEO_CAPTURE`。
*   `io_modes` is a bitmask describing what types of buffers can be handled. Possible values include the following:

    -`VB2_MMAP`：在内核中分配并通过`mmap()`访问的缓冲区；vmalloc‘ed 和连续的 DMA 缓冲区通常属于这种类型。

    -`VB2_USERPTR`：这是针对用户空间中分配的缓冲区。 通常，只有可以执行分散/聚集 I/O 的设备才能处理用户空间缓冲区。 但是，不支持巨型页面的连续 I/O。 有趣的是，Videobuf2 支持用户空间分配的连续缓冲区。 不过，实现这些功能的唯一方法是使用某种特殊机制，例如树外 Android`pmem`驱动程序。

    -`VB2_READ, VB2_WRITE`：这些是通过`read()`和`write()`系统调用提供的用户空间缓冲区。

*   `lock`是流 ioctls 的序列化锁的互斥体。 通常使用与`video_device->lock`相同的互斥锁来设置此锁，`video_device->lock`是主要的序列化锁。 但是，如果某些非流 ioctls 需要很长时间才能执行，那么您可能希望在这里使用不同的锁，以防止在等待另一个操作完成时`VIDIOC_DQBUF`被阻塞。
*   `ops`表示特定于驱动程序的回调，以设置此队列并控制流操作。 它属于`struct vb2_ops`类型。 我们将在下一节详细研究此结构。
*   The `mem_ops` field is where the driver tells videobuf2 what kind of buffers it is actually using; it should be set to one of `vb2_vmalloc_memops`, `vb2_dma_contig_memops`, or `vb2_dma_sg_memops`. These are the three basic types of buffer allocation videobuf2 implements:

    -第一个是**vmalloc Buffers**分配器，通过为缓冲区分配内存`vmalloc()`，因此在内核空间中实际上是连续的，不能保证物理上是连续的。

    -第二个是**连续 DMA 缓冲区**分配器，通过该分配器，内存在内存中是物理连续的，通常是因为硬件不能对任何其他类型的缓冲区执行 DMA。 该分配器由一致的 DMA 分配支持。

    -最后一个是**S/G DMA Buffers**分配器，其中缓冲区分散在内存中。 如果硬件可以执行分散/聚集 DMA，则这是方式。 显然，这涉及到流式 DMA。

    根据使用的内存分配器的类型，驱动程序应包括以下三个标头之一：

    ```
    /* => vb_queue->mem_ops = &vb2_vmalloc_memops;*/
    #include <media/videobuf2-vmalloc.h>
    /* => vb_queue->mem_ops = &vb2_dma_contig_memops; */
    #include <media/videobuf2-dma-contig.h> 
    /* => vb_queue->mem_ops = &vb2_dma_sg_memops; */
    #include <media/videobuf2-dma-sg.h> 
    ```

    到目前为止，还没有出现任何现有分配器都不能为设备执行此工作的情况。 但是，如果出现这种情况，驱动程序作者可以通过`vb2_mem_ops`创建一组自定义操作，以满足该需求。 这是没有限制的。

*   如果没有设置，您可能不关心`buf_ops`，因为它是由`vb2`内核提供的。 但是，它包含在用户空间和内核空间之间传递缓冲区信息的回调。
*   `min_buffers_needed`是开始流之前所需的最小缓冲区数。 如果该值不为零，则在用户空间至少排队了那么多个缓冲区之前，不会调用`vb2_queue->ops->start_streaming`。 换句话说，它表示 DMA 引擎在启动之前需要具有的可用缓冲区数量。
*   `bufs`是指向此队列中的个缓冲区的指针数组。 它的最大值为`VB2_MAX_FRAME`，对应于`vb2`内核允许的每个队列的最大缓冲区数。 它被设置为`32`，这已经是一个相当可观的值了。
*   `num_buffers`是队列中已分配/已使用的缓冲区数量。

#### 特定于驱动程序的ﬁc++流回调

网桥驱动程序需要公开用于管理缓冲区队列的个函数集合，包括队列和缓冲区初始化。 这些函数将处理来自用户空间的缓冲区分配、排队和流相关请求。 这可以通过设置`struct vb2_ops`的实例来实现，定义如下：

```
struct vb2_ops {
    int (*queue_setup)(struct vb2_queue *q,
                       unsigned int *num_buffers,                        unsigned int *num_planes,
                       unsigned int sizes[],                        struct device *alloc_devs[]);
    void (*wait_prepare)(struct vb2_queue *q);
    void (*wait_finish)(struct vb2_queue *q);
    int (*buf_init)(struct vb2_buffer *vb);
    int (*buf_prepare)(struct vb2_buffer *vb);
    void (*buf_finish)(struct vb2_buffer *vb);
    void (*buf_cleanup)(struct vb2_buffer *vb);
    int (*start_streaming)(struct vb2_queue *q,                            unsigned int count);
    void (*stop_streaming)(struct vb2_queue *q);
    void (*buf_queue)(struct vb2_buffer *vb);
};
```

下面是此结构中每个回调的用途：

*   `queue_setup`: This callback function is called by the driver's `v4l2_ioctl_ops.vidioc_reqbufs()` method (in response to `VIDIOC_REQBUFS` and `VIDIOC_CREATE_BUFS` ioctls) to adjust the buffer count and size. This callback's goal is to inform videobuf2-core of how many buffers and planes per buffer it requires, as well as the size and allocator context for each plane. In other words, the chosen vb2 memory allocator calls this method for negotiating with the driver about the number of buffers and planes per buffer to be used during streaming. `3` is a good choice for the minimum number of buffers since most DMA engines need at least `2` buffers in the queue. The parameters of this callback are defined as follows:

    -`q`是`vb2_queue`指针。

    -`num_buffers`是指向应用程序请求的缓冲区数量的指针。 然后，驱动程序应设置在此`*num_buffers`字段中分配的准予缓冲区数量。 由于此回调可以在协商过程中调用两次，因此在设置此回调之前，您应该检查`queue->num_buffers`以了解已分配的缓冲区数量。

    -`num_planes`包含保持帧所需的不同视频平面的数量。 这应该由司机设置。

    -`sizes`包含每个平面的大小(以字节为单位)。 对于单平面系统，只应设置`size[0]`。

    -`alloc_devs`是可选的每平面分配器特定的设备阵列。 将其视为指向分配上下文的指针。

    下面是`queue_setup`回调的一个示例：

    ```
    /* Setup vb_queue minimum buffer requirements */
    static int rcar_drif_queue_setup(struct vb2_queue *vq,
                                 unsigned int *num_buffers,                             unsigned int *num_planes,
                                 unsigned int sizes[],                              struct device *alloc_devs[])
    {
        struct rcar_drif_sdr *sdr = vb2_get_drv_priv(vq);
        /* Need at least 16 buffers */
        if (vq->num_buffers + *num_buffers < 16)
            *num_buffers = 16 - vq->num_buffers;
        *num_planes = 1;
        sizes[0] = PAGE_ALIGN(sdr->fmt->buffersize);
        rdrif_dbg(sdr, "num_bufs %d sizes[0] %d\n",
                  *num_buffers, sizes[0]);
        return 0;
    }
    ```

*   在为缓冲区分配内存后，或在新的`USERPTR`缓冲区排队后，对缓冲区调用一次`buf_init`。 例如，这可用于固定页面、验证邻接性和设置 IOMMU 映射。
*   在`VIDIOC_QBUF`ioctl 的执行路径上调用`buf_prepare`。 它应该为排队到 DMA 引擎准备缓冲区。 准备缓冲器，并将用户空间虚拟地址或用户地址转换为物理地址。
*   在每个`DQBUF`ioctl 上调用`buf_finish`。 例如，它可以用于高速缓存同步和从退回缓冲区复制回来。
*   在释放/释放内存之前调用`buf_cleanup`。 它可以用来解映像内存之类的东西。
*   `buf_queue`：Videobuf2 内核在调用此回调之前设置缓冲区中的`VB2_BUF_STATE_ACTIVE`标志。 但是，它是代表`VIDIOC_QBUF`ioctl 调用的。 用户空间一个接一个地对缓冲区进行排队。 此外，缓冲器排队的速度可以快于网桥设备将数据从捕获设备抓取到缓冲器的速度。 同时，在发出`VIDIOC_DQBUF`之前，可能会多次调用`VIDIOC_QBUF`。 建议驱动程序维护一个排队等待 DMA 的缓冲区列表，以便在任何 DMA 完成的情况下，填充的缓冲区将从列表中移出，同时通过填充其时间戳并将缓冲区添加到 Videobuf2 的完成缓冲区列表来提供给`vb2`内核，并在必要时更新 DMA 指针。 粗略地说，这个回调函数应该向驱动程序 DMA 队列添加一个缓冲区，并在该缓冲区上启动 DMA。 与此同时，驱动程序通常会重新实现自己的缓冲区数据结构，该结构构建在通用的`vb2_v4l2_buffer`结构之上，但为了解决我们刚才描述的排队问题，添加了一个列表。 以下是这样的自定义缓冲区数据结构的示例：

    ```
    struct dcmi_buf {
       struct vb2_v4l2_buffer vb;
       dma_addr_t paddr; /* the bus address of this buffer */
       size_t size;
       struct list_head list; /* list entry for tracking    buffers */
    };
    ```

*   `start_streaming`启动用于流的 DMA 引擎。 在开始流式处理之前，您必须首先检查是否已将最小数量的缓冲区排队。 如果没有，您应该返回`-ENOBUFS`，`vb2`框架将在下一次缓冲区排队时再次调用此函数，直到有足够的缓冲区可用来实际启动 DMA 引擎。 如果支持以下各项，还应在子设备上启用流式处理：`v4l2_subdev_call(subdev, video, s_stream, 1)`。 您应该从缓冲区队列中获取下一帧，并在其上启动 DMA。 通常，中断发生在捕获新帧之后。 处理程序的工作是从内部缓冲区列表中移除新帧(使用`list_del()`)，并将其返回给`vb2`框架(通过`vb2_buffer_done()`)，同时更新序列计数器域和时间戳。
*   `stop_streaming`停止所有挂起的 DMA 操作，停止 DMA 引擎，并释放 DMA 通道资源。如果支持以下操作，还应禁用子设备上的流：`v4l2_subdev_call(subdev, video, s_stream, 0)`。 必要时禁用中断。 由于驱动程序维护了一个排队等待 DMA 的缓冲器列表，所以该列表中排队的所有缓冲器必须在错误状态下返回给 VB2。

#### 初始化和释放 VB2 队列

为了让驱动程序完成队列初始化，它应该调用`vb2_queue_init()`函数，给定队列作为参数。 但是，`vb2_queue`结构应该首先由驱动程序分配。 此外，在调用此函数之前，驱动程序必须已清除其内容，并为一些必需条目设置初始值。 这些必需的值是`q->ops`、`q->mem_ops`、`q->type`和`q->io_modes`。 否则，队列初始化将失败，如下面的`vb2_core_queue_init()`函数所示，该函数被调用，并从`vb2_queue_init()`内检查其返回值：

```
int vb2_core_queue_init(struct vb2_queue *q)
{
    /*
     * Sanity check
     */
    if (WARN_ON(!q) || WARN_ON(!q->ops) ||          WARN_ON(!q->mem_ops) ||
         WARN_ON(!q->type) || WARN_ON(!q->io_modes) ||
         WARN_ON(!q->ops->queue_setup) ||          WARN_ON(!q->ops->buf_queue))
        return -EINVAL;
    INIT_LIST_HEAD(&q->queued_list);
    INIT_LIST_HEAD(&q->done_list);
    spin_lock_init(&q->done_lock);
    mutex_init(&q->mmap_lock);
    init_waitqueue_head(&q->done_wq);
    q->memory = VB2_MEMORY_UNKNOWN;
    if (q->buf_struct_size == 0)
        q->buf_struct_size = sizeof(struct vb2_buffer);
    if (q->bidirectional)
        q->dma_dir = DMA_BIDIRECTIONAL;
    else
        q->dma_dir = q->is_output ? DMA_TO_DEVICE :         DMA_FROM_DEVICE;
    return 0;
}
```

前面的摘录显示了内核中`vb2_core_queue_init()`的主体。 这个内部 API 是一个纯粹的基于的c 初始化方法，它只是执行一些健全性检查，并初始化基本的数据结构(列表、互斥锁和自旋锁)。

# 子设备的概念

在 V4L2 子系统的早期，只有两种主要的数据结构：

*   `struct video_device`：这是`/dev/<type>X`出现的结构。
*   `struct vb2_queue`：这负责缓冲区管理。

在那个没有那么多 IP 块嵌入视频网桥的时代，这就足够了。 如今，SoC 中的图像块嵌入了如此多的 IP 块，每个 IP 块都通过卸载特定的任务来发挥特定的作用，如图像大小调整、图像转换和视频去隔行功能。 为了使用模块化方法来解决这种多样性，引入了子器件的概念。 这为硬件的软件建模带来了模块化方法，允许将每个硬件组件抽象为软件块。

使用这种方法，参与处理管道的每个 IP 块(桥接设备除外)都被视为一个子设备，甚至是摄像机传感器本身。 桥接视频设备节点具有`/dev/videoX`模式，而它们一侧的子设备使用`/dev/v4l-subdevX`模式(假设它们在创建节点之前设置了适当的标志)。

重要音符

为了更好地理解桥接设备和子设备之间的区别，您可以将桥接设备视为处理管道中的最后一个元素，有时是负责 DMA 事务的元素。 一个例子是 Atmel-**ISC**(**图像传感器控制器**)，它从`drivers/media/platform/atmel/atmel-isc.c`：`Sensor-->PFE-->WB-->CFA-->CC-->GAM-->CSC-->CBC-->SUB-->RLP-->DMA`中的驱动程序中提取。 我们鼓励您在此驱动程序中查看每个元素的含义。

从编码的角度来看，驱动程序应该包括`<media/v4l-subdev.h>`，它定义了`struct v4l2_subdev`结构，该结构是用于实例化内核中的子设备的抽象数据结构。 该结构定义如下：

```
struct v4l2_subdev {
#if defined(CONFIG_MEDIA_CONTROLLER)
    struct media_entity entity;
#endif
    struct list_head list; 
    struct module *owner;
    bool owner_v4l2_dev;
    u32 flags;
    struct v4l2_device *v4l2_dev;
    const struct v4l2_subdev_ops *ops;
[...]
    struct v4l2_ctrl_handler *ctrl_handler;
    char name[V4L2_SUBDEV_NAME_SIZE];
    u32 grp_id; void *dev_priv;
    void *host_priv;
    struct video_device *devnode;
    struct device *dev;
    struct fwnode_handle *fwnode;
    struct device_node *of_node;
    struct list_head async_list;
    struct v4l2_async_subdev *asd;
    struct v4l2_async_notifier *notifier;
    struct v4l2_async_notifier *subdev_notifier;
    struct v4l2_subdev_platform_data *pdata;
};
```

此结构的`entity`字段将在下一章[*第 8 章*](08.html#_idTextAnchor342)*中讨论，并与 V4L2 异步和媒体控制器框架*集成。 与此同时，有一些我们不感兴趣的领域已经被移除。

但是，结构中的其他字段定义如下：

*   `list`属于`list_head`类型，内核使用它将当前子设备插入其所属的`v4l2_device`维护的子设备列表中。
*   `owner`由核心设置，并表示拥有该结构的模块。
*   `flags` represents the sub-device flags that the driver can set and that can have the following values:

    -`V4L2_SUBDEV_FL_IS_I2C`：如果该子器件实际上是 I2C 器件，则应设置该标志。

    -如果该子设备是 SPI 设备，则应设置`V4L2_SUBDEV_FL_IS_SPI`。

    -如果子设备需要设备节点(著名的`/dev/v4l-subdevX`条目)，则应设置`V4L2_SUBDEV_FL_HAS_DEVNODE`。 使用该标志的 API 是`v4l2_device_register_subdev_nodes()`，它将在稍后讨论，并由网桥调用以创建子设备节点条目。

    -`V4L2_SUBDEV_FL_HAS_EVENTS`表示该子设备生成事件。

*   `v4l2_dev`由内核在子设备注册上设置，是指向该子设备所属的`struct 4l2_device`的指针。
*   `ops`是可选的。 这是指向`struct v4l2_subdev_ops`的指针，它代表一组操作，应该由驱动程序设置，以提供内核可以依赖于该子设备的回调。
*   `ctrl_handler`是指向`struct v4l2_ctrl_handler`的指针。 它表示此子设备提供的控制列表，我们将在*V4L2 Controls Infrastructure*部分看到。
*   `name`是子设备的唯一名称。 它应在子设备初始化后由驱动程序设置。 对于 I2C 变量的初始化，内核分配的默认名称为`("%s %d-%04x", driver->name, i2c_adapter_id(client->adapter), client->addr)`。 当包含**媒体控制器**的支持时，此名称用作媒体实体名称。
*   `grp_id`是驱动程序特定的，在异步模式下由内核提供，用于对相似的子设备进行分组。
*   `dev_priv`是指向设备私有数据(如果有的话)的指针。
*   `host_priv`是指向附接子设备的设备使用的私有数据的指针。
*   `devnode`是该子设备的设备节点，由内核在调用`v4l2_device_register_subdev_nodes()`时设置，不要与构建在相同结构的顶部上的桥接设备混淆。 您应该记住，每个`v4l2`元素(无论是子设备还是网桥)都是视频设备。
*   `dev`是指向物理设备的指针(如果有)。 驱动程序可以使用`void``v4l2_set_subdevdata(struct v4l2_subdev *sd, void *p)`设置此值，也可以使用`void *v4l2_get_subdevdata(const struct v4l2_subdev *sd)`获取此值。
*   `fwnode`是此子设备的固件节点对象句柄。 在较早的内核版本中，此成员过去是`struct device_node *of_node`，并指向子设备的**设备树**(**dt**)节点。 然而，内核开发人员发现使用通用的`struct fwnode_handle`更好，因为它允许在设备树节点/ACPI 设备之间进行切换，根据该设备树节点/ACPI 设备在平台上使用它。 换句话说，它不是`dev->of_node->fwnode`就是`dev->fwnode`，以非`NULL`为准。

`async_list`、`asd`、`subdev_notifier`和`notifier`元素是 V4L2-异步框架的一部分，我们将在下一节中看到。 不过，此处简要介绍了这些元素：

*   `async_list`：当向异步核心注册时，核心使用此成员将此子设备链接到全局`subdev_list`(这是不属于任何通知器的孤立子设备的列表，这意味着此子设备已在其父网桥之前注册)或链接到其父网桥的`notifier->done`列表。 我们将在下一章[*第 8 章*](08.html#_idTextAnchor342)*与 V4L2 异步和媒体控制器框架*集成中详细讨论这一点。
*   `asd`：此字段为`struct v4l2_async_subdev`类型，并抽象异步核心中的该子设备。
*   `subdev_notifier`：这是该子设备隐式注册的通知器，以防需要通知它探测其他子设备。 它通常用于系统，其中流式流水线涉及多个子设备，其中子设备 N 需要被通知对子设备 N-1 的探测。
*   `notifier`：这是由异步核心设置的，与其底层`.asd`异步子设备匹配的通知器相对应。
*   `pdata`：这是子设备平台数据的公共部分。

## 子设备初始化

每个子设备驱动程序都必须有一个`struct v4l2_subdev`结构，可以是独立的，也可以是嵌入到较大的特定于设备的结构中。 建议使用第二种情况，因为它允许跟踪设备状态。 以下是典型设备特定结构的示例：

```
struct mychip_struct {
    struct v4l2_subdev sd;
[...]
    /* device speific fields*/
[...]
};
```

在访问 V4L2 子设备之前，需要使用`v4l2_subdev_init()`API 进行初始化。 但是，对于具有基于 I2C 或 SPI 的控制接口(通常是摄像头传感器)的子设备，内核提供`v4l2_spi_subdev_init()`和`v4l2_i2c_subdev_init()` 变体：

```
void v4l2_subdev_init(struct v4l2_subdev *sd,
                       const struct v4l2_subdev_ops *ops)
void v4l2_i2c_subdev_init(struct v4l2_subdev *sd,
                       struct i2c_client *client,
                       const struct v4l2_subdev_ops *ops)
void v4l2_spi_subdev_init(struct v4l2_subdev *sd,
                          struct spi_device *spi,
                          const struct v4l2_subdev_ops *ops)
```

所有这些 API 都将指向`struct v4l2_subdev`结构的指针作为第一个参数。 然后，使用我们特定于设备的数据结构注册我们的子设备将如下所示：

```
v4l2_i2c_subdev_init(&mychip_struct->sd, client, subdev_ops);
/*or*/
v4l2_subdev_init(&mychip_struct->sd, subdev_ops);
```

`spi`/`i2c`变量包装了`v4l2_subdev_init()`函数。 此外，它们还需要底层的特定于总线的结构作为第二个参数。 此外，这些特定于总线的变体将存储子设备对象(作为第一个参数给出)作为低级的特定于总线的设备数据，反之亦然，方法是将低级的特定于总线的结构存储为子设备的私有数据。 这样，`i2c_client`(或`spi_device`)和`v4l2_subdev`彼此指向，例如，通过拥有指向 I2C 客户端的指针，您可以调用`i2c_set_clientdata()`(如`struct v4l2_subdev *sd = i2c_get_clientdata(client);`)来获取指向我们的内部子设备对象的指针，并使用`container_of`宏(如`struct mychip_struct *foo = container_of(sd, struct mychip_struct, sd);`)来获取指向芯片特定结构的指针。 另一方面，如果拥有指向子设备对象的指针，则可以使用`v4l2_get_subdevdata()`来获取底层总线特定结构。

正如引入`struct v4l2_subdev`数据结构时所解释的那样，最不重要但并非最后一点是，这些特定于总线的变体将扰乱子设备名称。 摘录`v4l2_i2c_subdev_init()`可以更好地理解这一点：

```
void v4l2_i2c_subdev_init(struct v4l2_subdev *sd,
                          struct i2c_client *client,
                          const struct v4l2_subdev_ops *ops)
{
   v4l2_subdev_init(sd, ops);
   sd->flags |= V4L2_SUBDEV_FL_IS_I2C;
   /* the owner is the same as the i2c_client's driver owner */
   sd->owner = client->dev.driver->owner;
   sd->dev = &client->dev;
   /* i2c_client and v4l2_subdev point to one another */     
   v4l2_set_subdevdata(sd, client);
   i2c_set_clientdata(client, sd);
   /* initialize name */
   snprintf(sd->name, sizeof(sd->name),
            "%s %d-%04x", client->dev.driver->name,    
            i2c_adapter_id(client->adapter), client->addr);
}
```

在前面三个初始化 API 中的每一个中，`ops`是最后一个参数，是指向表示由子设备公开的/su操作的`struct v4l2_subdev_ops`的指针。 不过，我们将在下一节中讨论这个问题。

## 子设备操作

子设备是以某种方式连接到主桥接设备的设备。 在整个媒体设备中，每个 IP(子设备)都有其功能集。 这些功能必须通过内核开发人员为常用功能定义好的回调向内核公开。 这就是`struct v4l2_subdev_ops`的目的。

然而，一些子设备可以执行如此之多的不同和无关的事情，以至于甚至`struct v4l2_subdev_ops`也被分成小的分类一致的子结构 OPS，每个集合相关的功能，使得`struct v4l2_subdev_ops`成为顶层 OPS 结构，如下所述：

```
struct v4l2_subdev_ops {
    const struct v4l2_subdev_core_ops          *core;
    const struct v4l2_subdev_tuner_ops         *tuner;
    const struct v4l2_subdev_audio_ops         *audio;
    const struct v4l2_subdev_video_ops         *video;
    const struct v4l2_subdev_vbi_ops           *vbi;
    const struct v4l2_subdev_ir_ops            *ir;
    const struct v4l2_subdev_sensor_ops        *sensor;
    const struct v4l2_subdev_pad_ops           *pad;
};
```

重要音符

应该只为底层 Charr 设备文件节点向用户空间公开的子设备提供操作。 注册后，此设备文件节点将具有与前面讨论的相同的文件操作，即`v4l2_fops`。 然而，正如我们在前面看到的，这些低级操作只包装(处理)`video_device->fops`。 因此，为了达到`v4l2_subdev_ops`，内核使用`subdev->video_device->fops`作为中介，并在初始化时为其分配另一个文件 ops(`subdev->vdev->fops = &v4l2_subdev_fops;`)，该文件 op 将包装并调用真正的 subdev ops。 这里的调用链是`v4l2_fops ==> v4l2_subdev_fops ==> our_custom_subdev_ops`。

您可以看到，前面的顶级操作结构由指向类别操作结构的指针组成，如下所示：

*   `v4l2_subdev_core_ops`类型的`core`：这是核心操作类别，提供通用回调，如日志记录和调试。 它还允许提供额外的和自定义的 ioctl(如果 ioctl 不适合任何类别，则特别有用)。
*   流开始时调用`v4l2_subdev_video_ops`类型的`video`：`.s_stream`。 它根据选定的帧大小和格式将不同的配置值写入摄像机的寄存器。
*   `v4l2_subdev_pad_ops`类型的`pad`：对于支持多种帧大小和图像采样格式的摄像机，这些操作允许用户从可用选项中进行选择。
*   `tuner`、`audio`、`vbi`和`ir`超出了本书的范围。
*   `sensor``v4l2_subdev_sensor_ops`类型：这涵盖摄像机传感器操作，通常是针对已知故障传感器，这些传感器需要跳过一些帧或线路，因为它们已损坏。

每个类别结构中的每个回调都对应一个 ioctl。 路由实际上是由`drivers/media/v4l2- core/v4l2-subdev.c`中定义的`subdev_do_ioctl()`在较低级别上完成的，并由对应于`v4l2_subdev_fops.unlocked_ioctl`的`subdev_ioctl()`间接调用。 真正的调用链应该是`v4l2_fops ==> v4l2_subdev_fops.unlocked_ioctl ==> our_custom_subdev_ops`。

这种顶层`struct v4l2_subdev_ops`结构的性质正好证实了 V4L2 可能支持的设备范围有多广。 子设备驱动程序不感兴趣的操作类别可以保留`NULL`。 还要注意的是，`.core`操作对于所有子 DEV 都是通用的。 这并不意味着它是强制性的；它仅仅意味着任何类别的子设备驱动程序都可以自由实现`.core`操作，因为它的回调是独立于类别的。

### 结构 V4L2_subdev_core_ops

此结构实现泛型回调，并具有以下定义：

```
struct v4l2_subdev_core_ops {
    int (*log_status)(struct v4l2_subdev *sd);
    int (*load_fw)(struct v4l2_subdev *sd);
    long (*ioctl)(struct v4l2_subdev *sd, unsigned int cmd,
                   void *arg);
[...]
#ifdef CONFIG_COMPAT
    long (*compat_ioctl32)(struct v4l2_subdev *sd,                            unsigned int cmd, 
                           unsigned long arg);
#endif
#ifdef CONFIG_VIDEO_ADV_DEBUG
   int (*g_register)(struct v4l2_subdev *sd,
                     struct v4l2_dbg_register *reg);
   int (*s_register)(struct v4l2_subdev *sd,
                     const struct v4l2_dbg_register *reg);
#endif
   int (*s_power)(struct v4l2_subdev *sd, int on);
   int (*interrupt_service_routine)(struct v4l2_subdev *sd,
                                    u32 status,                                     bool *handled);
   int (*subscribe_event)(struct v4l2_subdev *sd,                           struct v4l2_fh *fh,
                          struct v4l2_event_subscription *sub);
   int (*unsubscribe_event)(struct v4l2_subdev *sd,
                          struct v4l2_fh *fh,                           struct v4l2_event_subscription *sub);
};
```

在前面的结构中，我们不感兴趣的字段已被删除。 其余的定义如下：

*   `.log_status`用于日志记录。 为此，您应该使用`v4l2_info()`宏。
*   `.s_power`将子设备(例如相机)置于省电模式(`on==0`)或正常操作模式(`on==1`)。
*   必须调用`.load_fw`操作来加载子设备的固件。
*   如果子设备提供额外的 ioctl 命令，则应定义`.ioctl`。
*   `.g_register`和`.s_register`仅用于高级调试，需要设置内核配置选项`CONFIG_VIDEO_ADV_DEBUG`。 这些操作允许读取和写入硬件寄存器，以响应`VIDIOC_DBG_G_REGISTER`和`VIDIOC_DBG_S_REGISTER`ioctls。 `reg`参数(类型为`v4l2_dbg_register`，在`include/uapi/linux/videodev2.h`中定义)由应用程序填充和给出。
*   `.interrupt_service_routine`在该子设备引发中断状态时，桥从其 IRQ 处理程序内调用`.interrupt_service_routine`(它应该使用`v4l2_subdev_call`)，以便该子设备处理细节。 `handled`是桥驱动程序提供的输出参数，但必须由子设备驱动程序填充，以便通知(如*TRUE 或 FALSE*)其处理结果。 我们处于 IRQ 环境中，所以一定不能睡觉。 I2C/SPI 总线后面的子器件可能应该在线程环境中调度它们的工作。
*   `.subscribe_event`和`.unsubscribe_event`用于订阅e 或取消订阅控制更改事件。 请看一下实现这一点的其他 V4L2 驱动程序，看看如何实现您的驱动程序。

### Struct V4L2_subdev_video_ops 或 struct V4L2_subdev_pad_ops

人们通常需要决定是实现`struct v4l2_subdev_video_ops`还是`struct v4l2_subdev_pad_ops`，因为有些回调在这两个结构中都是多余的。 问题是，`struct v4l2_subdev_video_ops`结构的回调是在 V4L2 设备以视频模式打开时使用的，视频模式包括电视、摄像头传感器和帧缓冲区。 到现在为止还好。 **PAD**的概念与媒体控制器框架紧密相关。 这意味着，只要不需要与媒体控制器框架集成，也就不需要`struct v4l2_subdev_pad_ops`。 但是，媒体控制器框架通过实体对象(我们稍后会看到)抽象子设备，实体对象通过 PAD 连接到其他元素。 在这种情况下，使用与焊盘相关的功能而不是与子器件相关的功能是有意义的，因此使用`struct v4l2_subdev_pad_ops`而不是`struct v4l2_subdev_video_ops`。

由于我们还没有引入媒体框架，所以我们只对定义如下的`struct v4l2_subdev_video_ops`结构感兴趣：

```
struct v4l2_subdev_video_ops {
    int (*querystd)(struct v4l2_subdev *sd, v4l2_std_id *std);
[...]
    int (*s_stream)(struct v4l2_subdev *sd, int enable);
    int (*g_frame_interval)(struct v4l2_subdev *sd,
                  struct v4l2_subdev_frame_interval *interval);
    int (*s_frame_interval)(struct v4l2_subdev *sd,
                  struct v4l2_subdev_frame_interval *interval);
[...]
};
```

在前面的摘录中，出于可读性的考虑，我删除了与电视和视频输出相关的回调以及那些与摄像设备无关的回调，这些回调在某种程度上对我们来说是无用的LSO。 对于常用的类型，它们的定义如下：

*   `querystd`：这是`VIDIOC_QUERYSTD()`ioctl 处理程序代码的回调。
*   `s_stream`：根据`enable`参数的值，通知驱动程序视频流将开始或已经停止。
*   `g_frame_interval`：这是`VIDIOC_SUBDEV_G_FRAME_INTERVAL()`ioctl 处理程序代码的回调。
*   `s_frame_interval`：这是`VIDIOC_SUBDEV_S_FRAME_INTERVAL()`ioctl 处理程序代码的回调。

### 结构 V4L2_SUBDEV_SENSOR_OPS

有些传感器在开始流式传输时会产生个初始垃圾帧。 这样的传感器可能需要一些时间才能确保其某些特性的稳定性。 这种结构使得有可能通知内核要跳过的帧数，以避免垃圾。 此外，一些传感器可能总是在顶部生成具有一定数量的损坏线条的图像，或者在这些线条中嵌入它们的元数据。 在这两种情况下，它们产生的结果帧总是损坏的。 此结构还允许我们指定每帧在被抓取之前要跳过的行数。

下面是`v4l2_subdev_sensor_ops`结构的定义：

```
struct v4l2_subdev_sensor_ops {
    int (*g_skip_top_lines)(struct v4l2_subdev *sd,                             u32 *lines);
    int (*g_skip_frames)(struct v4l2_subdev *sd, u32 *frames);
};
```

`g_skip_top_lines`用于指定传感器的每个图像中要跳过的行数，而`g_skip_frames`允许我们指定要跳过的初始帧数，以避免垃圾，如下例所示：

```
#define OV5670_NUM_OF_SKIP_FRAMES	2
static int ov5670_get_skip_frames(struct v4l2_subdev *sd,                                   u32 *frames)
{
    *frames = OV5670_NUM_OF_SKIP_FRAMES;
    return 0;
}
```

`lines`和`frames`参数是输出参数。 每个回调都应该返回`0`。

### 调用子设备操作

毕竟，如果提供了个回调函数，那么它们就是要被调用的。 也就是说，调用操作回调与直接调用一样简单，如下所示：

```
err = subdev->ops->video->s_stream(subdev, 1);
```

但是，有一种更方便、更安全的方法来实现这一点，即使用`v4l2_subdev_call()`宏：

```
err = v4l2_subdev_call(subdev, video, s_stream, 1);
```

在`include/media/v4l2-subdev.h`中定义的宏将执行以下操作：

*   它将首先检查子设备是否为`NULL`，否则返回`-ENODEV`。
*   如果类别(我们示例中的`subdev->video`)或回调本身(我们示例中的`subdev->video->s_stream`)是`NULL`，则它将返回`-ENOIOCTLCMD`，否则它将返回`subdev->ops->video->s_stream`操作的实际结果。

也可以调用个子设备的全部或子集：

```
v4l2_device_call_all(dev, 0, core, g_chip_ident, &chip);
```

跳过任何不支持此回调的子设备，并忽略错误结果。 如果要检查错误，请使用以下命令：

```
err = v4l2_device_call_until_err(dev, 0, core,                                  g_chip_ident, &chip);
```

除`-ENOIOCTLCMD`以外的任何错误都将带着该错误退出此e 循环。 如果没有发生错误(除`- ENOIOCTLCMD`外)，则返回`0`。

## 传统子设备(Un)注册

根据媒体设备的性质，有两种方式可将子设备注册到网桥：

1.  **同步方式**：这是传统方式。 在此模式下，网桥驱动程序负责注册子设备。 子设备驱动程序是从网桥驱动程序内部实现的，或者您必须为网桥驱动程序找到一种方法来获取它所负责的子设备的句柄。 通常是通过平台数据，或者通过网桥驱动程序暴露一组将由子设备驱动程序使用的 API 来实现的，这将允许网桥驱动程序知道这些子设备(例如，通过在私有内部列表中跟踪它们)。使用这种方法，网桥驱动程序必须知道连接到它的子设备，并且确切地知道何时注册它们。 这通常是内部子设备的情况，例如 SoC 或复杂 PCI(E)板中的视频数据处理单元，或者 USB 摄像机中的摄像机传感器或连接到 SoC 的摄像机传感器。
2.  **异步模式**：在这种模式下，系统可以独立于网桥设备使用子设备的信息，这通常是基于设备树的系统的情况。 这将在下一章[*第 8 章*](08.html#_idTextAnchor342)，*集成 V4L2 异步和媒体控制器框架*中讨论。

但是，为了让网桥驱动程序注册子设备，它必须调用`v4l2_device_register_subdev()`，同时必须调用`v4l2_device_unregister_subdev()`来注销该子设备。 同时，在向核心注册子设备之后，可能只需要为设置了标志`V4L2_SUBDEV_FL_HAS_DEVNODE`的子设备创建其各自的字符文件节点`/dev/v4l-subdevX`。 为此，您可以使用`v4l2_device_register_subdev_nodes()`：

```
int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,
                                struct v4l2_subdev *sd)
void v4l2_device_unregister_subdev(struct v4l2_subdev *sd)
int v4l2_device_register_subdev_nodes(struct                                       v4l2_device *v4l2_dev)
```

`v4l2_device_register_subdev()`将把`sd`插入`v4l2_dev->subdevs`，这是该 V4L2 设备维护的子设备列表。 如果`subdev`模块在注册之前消失，则此操作可能失败。 成功调用此函数后，`subdev->v4l2_dev`字段指向`v4l2_device`。 如果成功，此函数将返回`0`，或者`v4l2_device_unregister_subdev()`将从该列表中删除`sd`。 然后，`v4l2_device_register_subdev_nodes()`遍历`v4l2_dev->subdevs`，并为设置了标志`V4L2_SUBDEV_FL_HAS_DEVNODE`的每个子设备创建特殊的字符文件节点(`/dev/v4l-subdevX`)。

重要音符

`/dev/v4l-subdevX`设备节点允许直接控制子设备的高级和硬件特定功能。

既然我们已经了解了子设备的初始化、操作和注册，让我们在下一节中看看 V4L2 控件。

# V4L2 控制基础设施

某些设备具有可由用户设置的控件，以便修改某些已定义的属性。 其中一些控件可能支持预定义值列表、默认值、调整等。 问题是，不同的设备可能会提供具有不同值的不同控件。 此外，虽然其中一些控件是标准的，但其他控件可能是特定于供应商的。 控件框架的主要目的是向用户呈现控件，而不假设控件的用途。 在本节中，我们只讨论标准控件。

控制框架依赖于两个主要对象，这两个对象都是在`include/media/v4l2- ctrls.h`中定义的，就像该框架提供的其余数据结构和 API 一样。 第一个是`struct v4l2_ctrl`。 此结构描述控件属性并跟踪控件的值。 第二个也是最后一个是`struct v4l2_ctrl_handler`，它跟踪所有控件。 它们的详细定义如下：

```
struct v4l2_ctrl_handler {
    [...]
    struct mutex *lock;
    struct list_head ctrls;
    v4l2_ctrl_notify_fnc notify;
    void *notify_priv;
    [...]
};
```

在前面的`struct v4l2_ctrl_handler`的定义摘录中，`ctrls`表示此处理程序拥有的控件的列表。 `notify`是每当控件更改值时调用的通知回调。 此回调是在保持处理程序的`lock`的情况下调用的。 最后，`notify_priv`是作为通知参数给出的上下文数据。 下一个是`struct v4l2_ctrl`，定义如下：

```
struct v4l2_ctrl {
    struct list_head node;
    struct v4l2_ctrl_handler *handler;
    unsigned int is_private:1;
    [...]
    const struct v4l2_ctrl_ops *ops;
    u32 id;
    const char *name;
    enum v4l2_ctrl_type type;
    s64 minimum, maximum, default_value;
    u64 step;
    unsigned long flags; [...]
}
```

这个结构本身就代表着控制，有重要的成员在场。 这些定义如下：

*   `node`用于在处理程序的控件列表中插入控件。
*   `handler`是此控件所属的处理程序。
*   `ops`属于`struct v4l2_ctrl_ops`类型，表示此控件的获取/设置操作。
*   `id`是此控件的 ID。
*   `name`是控件的名称。
*   `minimum`和`maximum`分别是控件接受的最小值和最大值。
*   `default_value`是控件的默认值。
*   `step`是此非菜单控件的递增/递减步骤。
*   `flags` covers the control's flags. While the whole flag list is defined in `include/uapi/linux/videodev2.h`, some of the commonly used ones are as follows:

    -`V4L2_CTRL_FLAG_DISABLED`，表示控件关闭

    -`V4L2_CTRL_FLAG_READ_ONLY`，表示只读控件

    -`V4L2_CTRL_FLAG_WRITE_ONLY`，用于只写控件

    加入时间：清华大学 2007 年 01 月 25 日下午 3：33

*   `is_private`, if set, will prevent this control from being added to any other handlers. It makes this control private to the initial handler where it is added. This can be used to prevent making a `subdev` control available in the V4L2 driver controls.

    重要音符

    **菜单控件**是这样的控件：不需要根据最小/最大/步长的值，而是允许在特定元素(通常在`enum`中)之间进行选择，例如一种菜单，因此得名为*菜单控件*。

V4L2 控件由唯一的 ID 标识。它们以`V4L2_CID_`为前缀，在`include/uapi/linux/v4l2-controls.h`中都可用。 视频采集设备中支持的常见标准控件如下(以下列表不是详尽的)：

```
#define V4L2_CID_BRIGHTNESS        (V4L2_CID_BASE+0)
#define V4L2_CID_CONTRAST          (V4L2_CID_BASE+1)
#define V4L2_CID_SATURATION        (V4L2_CID_BASE+2)
#define V4L2_CID_HUE	(V4L2_CID_BASE+3)
#define V4L2_CID_AUTO_WHITE_BALANCE      (V4L2_CID_BASE+12)
#define V4L2_CID_DO_WHITE_BALANCE  (V4L2_CID_BASE+13)
#define V4L2_CID_RED_BALANCE (V4L2_CID_BASE+14)
#define V4L2_CID_BLUE_BALANCE      (V4L2_CID_BASE+15)
#define V4L2_CID_GAMMA       (V4L2_CID_BASE+16)
#define V4L2_CID_EXPOSURE    (V4L2_CID_BASE+17)
#define V4L2_CID_AUTOGAIN    (V4L2_CID_BASE+18)
#define V4L2_CID_GAIN  (V4L2_CID_BASE+19)
#define V4L2_CID_HFLIP (V4L2_CID_BASE+20)
#define V4L2_CID_VFLIP (V4L2_CID_BASE+21)
[...]
#define V4L2_CID_VBLANK  (V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 1) #define V4L2_CID_HBLANK  (V4L2_CID_IMAGE_SOURCE_CLASS_BASE + 2) #define V4L2_CID_LINK_FREQ (V4L2_CID_IMAGE_PROC_CLASS_BASE + 1)
```

上面的列表仅包括标准控件。 若要支持自定义控件，应根据控件的基类描述符添加其 ID，并确保该 ID 不是重复的。 要向驱动程序添加控制支持，应首先使用`v4l2_ctrl_handler_init()`宏来初始化控制处理程序。 此宏接受要初始化的处理程序以及该处理程序可以引用的控件数量，如其原型所示：

```
v4l2_ctrl_handler_init(hdl, nr_of_controls_hint)
```

完成控制处理程序后，可以在此控制处理程序上调用`v4l2_ctrl_handler_free()`以释放其资源。 一旦控件处理程序初始化，就可以创建控件并将其添加到其中。 对于标准的 V4L2 控件，您可以使用`v4l2_ctrl_new_std()`来分配和初始化新控件：

```
struct v4l2_ctrl *v4l2_ctrl_new_std(                               struct v4l2_ctrl_handler *hdl,
                               const struct v4l2_ctrl_ops *ops,                               u32 id, s64 min, s64 max,                                u64 step, s64 def);
```

在大多数字段中，此函数将基于控件 ID。但是，对于自定义控件(这里不讨论)，您应该使用`v4l2_ctrl_new_custom()`帮助器。 在前面的原型中，以下元素定义如下：

*   `hdl`表示先前初始化的控件处理程序。
*   `ops`属于`struct v4l2_ctrl_ops`类型，表示控制操作。
*   `id`是控件 ID，定义为`V4L2_CID_*`。
*   `min`是此控件可以接受的最小值。 根据控件 ID 的不同，该值可能会被内核损坏。
*   `max`是此控件可以接受的最大值。 根据控件 ID 的不同，该值可能会被内核损坏。
*   `step`是控件的步长值。
*   `def`是控件的默认值。

控件应该是设置/获取的。 这就是前面的操作论证的目的。 这意味着在初始化控件之前，您应该首先定义在设置/获取此控件的值时将调用的操作。 也就是说，整个控制列表可以由相同的操作人员处理。 在这种情况下，操作回调必须使用`switch ... case`来处理不同的控件。

如前所述，控制操作属于`struct v4l2_ctrl_ops`类型，定义如下：

```
struct v4l2_ctrl_ops {
    int (*g_volatile_ctrl)(struct v4l2_ctrl *ctrl);
    int (*try_ctrl)(struct v4l2_ctrl *ctrl);
    int (*s_ctrl)(struct v4l2_ctrl *ctrl);
};
```

前面的结构由三个回调组成，每个回调都有特定的用途：

*   `g_volatile_ctrl`获取给定控件的新值。 提供此回调仅对易失性(由硬件本身更改的控件，并且大多数时间是只读的，例如信号强度或自动增益)控件才有意义。
*   如果设置，则调用`try_ctrl`来测试要应用的控件的值是否有效。 仅当通常的最小/最大/步骤检查不充分时，提供此回调才有意义。
*   `s_ctrl`被调用来设置控件的值。

或者，您可以在控件处理程序上调用`v4l2_ctrl_handler_setup()`，以便将此处理程序的控件设置为其默认值。 这有助于确保硬件和驱动程序的内部数据结构同步：

```
int v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler *hdl);
```

此函数迭代给定处理程序中的所有控件，并使用每个控件的默认值调用`s_ctrl`回调。

为了总结我们在整个 V4L2 控件接口部分看到的内容，现在让我们更详细地学习`OV7740`摄像机传感器驱动程序的摘录(在`drivers/media/i2c/ov7740.c`中)，特别是处理 V4L2 控件的部分。

首先，我们实现了控件`ops->sg_ctrl`回调：

```
static int ov7740_get_volatile_ctrl(struct v4l2_ctrl *ctrl)
{
    struct ov7740 *ov7740 = container_of(ctrl->handler,
    struct ov7740, ctrl_handler);
    int ret;
    switch (ctrl->id) {
    case V4L2_CID_AUTOGAIN:
        ret = ov7740_get_gain(ov7740, ctrl);
        break;
    default:
        ret = -EINVAL;
        break;
    }
    return ret;
}
```

前面的回调只处理`V4L2_CID_AUTOGAIN`的控件 ID。 这是有意义的，因为在*AUTO*模式下，硬件可能会更改增益值。 此驱动程序按如下方式实现`ops->s_ctrl`控件：

```
static int ov7740_set_ctrl(struct v4l2_ctrl *ctrl)
{
    struct ov7740 *ov7740 =
             container_of(ctrl->handler, struct ov7740,                           ctrl_handler);
    struct i2c_client *client =     v4l2_get_subdevdata(&ov7740->subdev); 
    struct regmap *regmap = ov7740->regmap;
    int ret;
    u8 val = 0;
[...]
    switch (ctrl->id) {
    case V4L2_CID_AUTO_WHITE_BALANCE:
        ret = ov7740_set_white_balance(ov7740, ctrl->val); break;
    case V4L2_CID_SATURATION:
        ret = ov7740_set_saturation(regmap, ctrl->val); break;
    case V4L2_CID_BRIGHTNESS:
        ret = ov7740_set_brightness(regmap, ctrl->val); break;
    case V4L2_CID_CONTRAST:
        ret = ov7740_set_contrast(regmap, ctrl->val); break;
    case V4L2_CID_VFLIP:
        ret = regmap_update_bits(regmap, REG_REG0C,
                                 REG0C_IMG_FLIP, val); break;
    case V4L2_CID_HFLIP:
        val = ctrl->val ? REG0C_IMG_MIRROR : 0x00;
        ret = regmap_update_bits(regmap, REG_REG0C,
                                 REG0C_IMG_MIRROR, val);
        break;
    case V4L2_CID_AUTOGAIN:
        if (!ctrl->val)
            return ov7740_set_gain(regmap, ov7740->gain->val);
        ret = ov7740_set_autogain(regmap, ctrl->val); break;
    case V4L2_CID_EXPOSURE_AUTO:
        if (ctrl->val == V4L2_EXPOSURE_MANUAL)
        return ov7740_set_exp(regmap, ov7740->exposure->val);
        ret = ov7740_set_autoexp(regmap, ctrl->val); break;
    default:
        ret = -EINVAL; break;
    }
[...]
    return ret;
}
```

前面的代码块还显示了使用`V4L2_CID_EXPOSURE_AUTO`控件实现菜单控件是多么容易，其可能值在`enum v4l2_exposure_auto_type`中枚举。 最后，将为控件创建提供的控件操作结构定义如下：

```
static const struct v4l2_ctrl_ops ov7740_ctrl_ops = {
    .g_volatile_ctrl = ov7740_get_volatile_ctrl,
    .s_ctrl = ov7740_set_ctrl,
};
```

定义后，此控件 OP 可用于初始化控件。 以下是`ov7740_init_controls()`方法(在`probe()`函数中调用)出于可读性目的的摘录、损坏和收缩：

```
static int ov7740_init_controls(struct ov7740 *ov7740)
{
[...]
    struct v4l2_ctrl *auto_wb;
    struct v4l2_ctrl *gain;
    struct v4l2_ctrl *vflip;
    struct v4l2_ctrl *auto_exposure;
    struct v4l2_ctrl_handler *ctrl_hdlr
    v4l2_ctrl_handler_init(ctrl_hdlr, 12);
    auto_wb = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,
                                V4L2_CID_AUTO_WHITE_BALANCE,                                 0, 1, 1, 1);
    vflip = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,
                              V4L2_CID_VFLIP, 0, 1, 1, 0);
    gain = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,
                             V4L2_CID_GAIN, 0, 1023, 1, 500);
    /* let's mark this control as volatile*/
    gain->flags |= V4L2_CTRL_FLAG_VOLATILE;
    contrast = v4l2_ctrl_new_std(ctrl_hdlr, &ov7740_ctrl_ops,
                                 V4L2_CID_CONTRAST, 0, 127,                                  1, 0x20);
    ov7740->auto_exposure =
                   v4l2_ctrl_new_std_menu(ctrl_hdlr,                                        &ov7740_ctrl_ops,
                                       V4L2_CID_EXPOSURE_AUTO,                                        V4L2_EXPOSURE_MANUAL,
                                       0, V4L2_EXPOSURE_AUTO);
[...]
    ov7740->subdev.ctrl_handler = ctrl_hdlr;
    return 0;
}
```

您可以在前面函数的返回路径上看到分配给子设备的控制处理程序。 最后，在代码中的某个地方(ov7740 的驱动程序从子设备的`v4l2_subdev_video_ops.s_stream`回调中执行此操作)，您应该将所有控件设置为其默认值：

```
ret = v4l2_ctrl_handler_setup(ctrl_hdlr);
if (ret) {
    dev_err(&client->dev, "%s control init failed (%d)\n",
             __func__, ret);
   goto error;
}
```

T这里是关于[https://www.kernel.org/doc/html/v4.19/media/kapi/v4l2-controls.html](https://www.kernel.org/doc/html/v4.19/media/kapi/v4l2-controls.html)的V4L2 控制的更多信息。

## 一句关于控件继承的话

子设备驱动程序通常实现网桥的 V4L2 驱动程序已经实现的控制。

当在`v4l2_subdev`和`v4l2_device`上调用`v4l2_device_register_subdev()`并设置了这两个字段的`ctrl_handler`时，子设备的控件将被添加到`v4l2_device`控件中(通过`v4l2_ctrl_add_handler()`帮助器，将给定处理程序的控件添加到另一个处理程序)。 将跳过已由`v4l2_device`实现的子设备控制。 这意味着 V4L2 驱动程序总是可以覆盖`subdev`控件。

也就是说，控件可能会在给定子设备上执行低级别的硬件特定操作，子设备驱动程序可能不希望该控件对 V4L2 驱动程序可用(因此不会添加到其控制处理程序中)。 在这种情况下，子设备驱动程序必须将控件的`is_private`成员设置为`1`(或`true`)。 这将使控件成为子设备的私有控件。

重要音符

即使子设备控件被添加到 V4L2 设备，它们仍然可以通过控制设备节点访问。

# 摘要

在本章中，我们介绍了 V4L2 网桥设备驱动程序的开发，以及子设备的概念。 我们了解了 V4L2 架构，现在熟悉了它的数据结构。 我们学习了 Videobuf2API，现在可以编写平台桥设备驱动程序了。 此外，我们应该能够实现子设备操作，并利用 Videobuf2 内核。

这一章可以看作是一幅宏大图景的第一部分，因为下一章仍然讨论 V4L2，但我们将讨论异步核心以及与媒体控制器框架的集成。